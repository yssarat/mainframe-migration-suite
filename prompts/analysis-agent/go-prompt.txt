You are an expert AWS architect specializing in mainframe modernization with deep expertise in Go development and cloud-native patterns.

CRITICAL: Generate complete, production-ready AWS artifacts for Go-based solutions in this EXACT structure, including architecture.md and readme.md files:

## LAMBDA_FUNCTIONS
### [function_name].go
```go
package main

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"time"

	"github.com/aws/aws-lambda-go/events"
	"github.com/aws/aws-lambda-go/lambda"
	"github.com/aws/aws-sdk-go-v2/aws"
	"github.com/aws/aws-sdk-go-v2/config"
	"github.com/aws/aws-sdk-go-v2/service/dynamodb"
	"github.com/aws/aws-sdk-go-v2/service/s3"
)

// MainframeRequest represents the input structure for mainframe processing
type MainframeRequest struct {
	JobID       string                 `json:"job_id"`
	BucketName  string                 `json:"bucket_name"`
	ObjectKey   string                 `json:"object_key"`
	Language    string                 `json:"language"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
}

// MainframeResponse represents the output structure
type MainframeResponse struct {
	StatusCode int                    `json:"statusCode"`
	Body       string                 `json:"body"`
	Headers    map[string]string      `json:"headers"`
	Timestamp  string                 `json:"timestamp"`
	Data       map[string]interface{} `json:"data,omitempty"`
}

// ProcessingResult represents the processing outcome
type ProcessingResult struct {
	Message   string                 `json:"message"`
	JobID     string                 `json:"job_id"`
	Status    string                 `json:"status"`
	Timestamp string                 `json:"timestamp"`
	Results   map[string]interface{} `json:"results,omitempty"`
}

// LambdaHandler handles the main Lambda function logic
type LambdaHandler struct {
	dynamoClient *dynamodb.Client
	s3Client     *s3.Client
	logger       *log.Logger
}

// NewLambdaHandler creates a new handler with AWS clients
func NewLambdaHandler() (*LambdaHandler, error) {
	cfg, err := config.LoadDefaultConfig(context.TODO())
	if err != nil {
		return nil, fmt.Errorf("failed to load AWS config: %w", err)
	}

	return &LambdaHandler{
		dynamoClient: dynamodb.NewFromConfig(cfg),
		s3Client:     s3.NewFromConfig(cfg),
		logger:       log.New(os.Stdout, "[MAINFRAME-PROCESSOR] ", log.LstdFlags|log.Lshortfile),
	}, nil
}

// HandleRequest processes the Lambda request
func (h *LambdaHandler) HandleRequest(ctx context.Context, request MainframeRequest) (MainframeResponse, error) {
	h.logger.Printf("Processing request for job: %s", request.JobID)

	// Process mainframe modernization logic here
	result, err := h.processMainframeData(ctx, request)
	if err != nil {
		h.logger.Printf("Error processing mainframe data: %v", err)
		return MainframeResponse{
			StatusCode: 500,
			Body:       fmt.Sprintf(`{"error": "%s", "timestamp": "%s"}`, err.Error(), time.Now().UTC().Format(time.RFC3339)),
			Headers:    map[string]string{"Content-Type": "application/json"},
			Timestamp:  time.Now().UTC().Format(time.RFC3339),
		}, nil
	}

	responseBody, _ := json.Marshal(result)
	return MainframeResponse{
		StatusCode: 200,
		Body:       string(responseBody),
		Headers:    map[string]string{"Content-Type": "application/json"},
		Timestamp:  time.Now().UTC().Format(time.RFC3339),
		Data:       map[string]interface{}{"processed": true},
	}, nil
}

// processMainframeData handles the core business logic
func (h *LambdaHandler) processMainframeData(ctx context.Context, request MainframeRequest) (*ProcessingResult, error) {
	// Implement your mainframe modernization logic here
	h.logger.Printf("Processing mainframe data for language: %s", request.Language)

	// Example: Store processing status in DynamoDB
	if err := h.updateJobStatus(ctx, request.JobID, "PROCESSING"); err != nil {
		return nil, fmt.Errorf("failed to update job status: %w", err)
	}

	// Example: Process data from S3
	if err := h.processS3Object(ctx, request.BucketName, request.ObjectKey); err != nil {
		return nil, fmt.Errorf("failed to process S3 object: %w", err)
	}

	// Update final status
	if err := h.updateJobStatus(ctx, request.JobID, "COMPLETED"); err != nil {
		return nil, fmt.Errorf("failed to update final status: %w", err)
	}

	return &ProcessingResult{
		Message:   "Mainframe modernization processing completed successfully",
		JobID:     request.JobID,
		Status:    "COMPLETED",
		Timestamp: time.Now().UTC().Format(time.RFC3339),
		Results: map[string]interface{}{
			"language":     request.Language,
			"processed_at": time.Now().UTC().Format(time.RFC3339),
		},
	}, nil
}

// updateJobStatus updates the job status in DynamoDB
func (h *LambdaHandler) updateJobStatus(ctx context.Context, jobID, status string) error {
	tableName := os.Getenv("JOBS_TABLE_NAME")
	if tableName == "" {
		return fmt.Errorf("JOBS_TABLE_NAME environment variable not set")
	}

	// Implementation for DynamoDB update
	h.logger.Printf("Updating job %s status to %s", jobID, status)
	return nil
}

// processS3Object processes an object from S3
func (h *LambdaHandler) processS3Object(ctx context.Context, bucket, key string) error {
	h.logger.Printf("Processing S3 object: s3://%s/%s", bucket, key)
	// Implementation for S3 processing
	return nil
}

func main() {
	handler, err := NewLambdaHandler()
	if err != nil {
		log.Fatalf("Failed to create handler: %v", err)
	}

	lambda.Start(handler.HandleRequest)
}
```

## IAM_ROLES
### [role_name].json
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:ListBucket"
      ],
      "Resource": [
        "arn:aws:s3:::mainframe-modernization-bucket",
        "arn:aws:s3:::mainframe-modernization-bucket/*"
      ]
    },
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:UpdateItem",
        "dynamodb:Query",
        "dynamodb:Scan"
      ],
      "Resource": "arn:aws:dynamodb:*:*:table/MainframeModernization*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "xray:PutTraceSegments",
        "xray:PutTelemetryRecords"
      ],
      "Resource": "*"
    }
  ]
}
```

## STEP_FUNCTIONS
### [workflow_name].json
```json
{
  "Comment": "Mainframe modernization workflow with Go Lambda functions",
  "StartAt": "InitializeProcessing",
  "States": {
    "InitializeProcessing": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:MainframeInitializer",
      "Parameters": {
        "job_id.$": "$.job_id",
        "bucket_name.$": "$.bucket_name",
        "object_key.$": "$.object_key",
        "language": "go"
      },
      "Retry": [
        {
          "ErrorEquals": ["Lambda.ServiceException", "Lambda.AWSLambdaException", "Lambda.SdkClientException"],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "HandleProcessingError",
          "ResultPath": "$.error"
        }
      ],
      "Next": "ProcessMainframeData"
    },
    "ProcessMainframeData": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:MainframeProcessor",
      "Parameters": {
        "job_id.$": "$.job_id",
        "bucket_name.$": "$.bucket_name",
        "object_key.$": "$.object_key",
        "language": "go",
        "processing_type": "modernization"
      },
      "TimeoutSeconds": 300,
      "HeartbeatSeconds": 60,
      "Next": "GenerateArtifacts"
    },
    "GenerateArtifacts": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:ArtifactGenerator",
      "Parameters": {
        "job_id.$": "$.job_id",
        "processed_data.$": "$.results",
        "target_language": "go",
        "artifact_types": ["lambda", "iam", "stepfunctions", "dynamodb"]
      },
      "Next": "CompleteProcessing"
    },
    "CompleteProcessing": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:ProcessingCompleter",
      "Parameters": {
        "job_id.$": "$.job_id",
        "status": "COMPLETED",
        "artifacts.$": "$.artifacts"
      },
      "End": true
    },
    "HandleProcessingError": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:ErrorHandler",
      "Parameters": {
        "job_id.$": "$.job_id",
        "error.$": "$.error",
        "original_input.$": "$",
        "language": "go"
      },
      "End": true
    }
  }
}
```

## DYNAMODB
### [table_name].json
```json
{
  "TableName": "MainframeModernizationJobs",
  "BillingMode": "PAY_PER_REQUEST",
  "AttributeDefinitions": [
    {
      "AttributeName": "job_id",
      "AttributeType": "S"
    },
    {
      "AttributeName": "created_at",
      "AttributeType": "S"
    },
    {
      "AttributeName": "status",
      "AttributeType": "S"
    }
  ],
  "KeySchema": [
    {
      "AttributeName": "job_id",
      "KeyType": "HASH"
    }
  ],
  "GlobalSecondaryIndexes": [
    {
      "IndexName": "StatusIndex",
      "KeySchema": [
        {
          "AttributeName": "status",
          "KeyType": "HASH"
        },
        {
          "AttributeName": "created_at",
          "KeyType": "RANGE"
        }
      ],
      "Projection": {
        "ProjectionType": "ALL"
      }
    },
    {
      "IndexName": "CreatedAtIndex",
      "KeySchema": [
        {
          "AttributeName": "created_at",
          "KeyType": "HASH"
        }
      ],
      "Projection": {
        "ProjectionType": "ALL"
      }
    }
  ],
  "StreamSpecification": {
    "StreamEnabled": true,
    "StreamViewType": "NEW_AND_OLD_IMAGES"
  },
  "PointInTimeRecoverySpecification": {
    "PointInTimeRecoveryEnabled": true
  },
  "SSESpecification": {
    "SSEEnabled": true,
    "SSEType": "KMS"
  },
  "Tags": [
    {
      "Key": "Project",
      "Value": "MainframeModernization"
    },
    {
      "Key": "Language",
      "Value": "Go"
    },
    {
      "Key": "Environment",
      "Value": "${Environment}"
    }
  ]
}
```

## ARCHITECTURE_DIAGRAM
### architecture.md
```ascii
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           MAINFRAME MODERNIZATION PLATFORM                      │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐             │
│  │   MAINFRAME     │    │      AWS        │    │    BUSINESS     │             │
│  │   DATA FILES    │───▶│   PROCESSING    │───▶│   APPLICATIONS  │             │
│  │                 │    │    LAYER        │    │                 │             │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘             │
│           │                       │                       │                     │
│           │                       │                       │                     │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐             │
│  │   S3 INPUT      │    │     LAMBDA      │    │    DYNAMODB     │             │
│  │   BUCKET        │───▶│   FUNCTIONS     │───▶│    TABLES       │             │
│  │                 │    │                 │    │                 │             │
│  │ • VSAM Files    │    │ • Converter     │    │ • Account Data  │             │
│  │ • Event Trigger │    │ • Processor     │    │ • Job Status    │             │
│  │ • Versioning    │    │ • Generator     │    │                 │             │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘             │
│           │                       │                       │                     │
│           │              ┌─────────────────┐              │                     │
│           │              │  STEP FUNCTIONS │              │                     │
│           └─────────────▶│   WORKFLOWS     │◀─────────────┘                     │
│                          │                 │                                    │
│                          │ • VSAM Conv.    │                                    │
│                          │ • Account Proc. │                                    │
│                          └─────────────────┘                                    │
│                                   │                                             │
│                          ┌─────────────────┐                                    │
│                          │   S3 OUTPUT     │                                    │
│                          │    BUCKET       │                                    │
│                          │                 │                                    │
│                          │ • Standard      │                                    │
│                          │ • Array         │                                    │
│                          │ • Variable      │                                    │
│                          └─────────────────┘                                    │
│                                   │                                             │
│                          ┌─────────────────┐                                    │
│                          │ NOTIFICATIONS   │                                    │
│                          │                 │                                    │
│                          │ • SNS Topics    │                                    │
│                          │ • CloudWatch    │                                    │
│                          │                 │                                    │
│                          └─────────────────┘                                    │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

## README
### readme.md
```markdown
## Executive Summary of the Modernization Approach

This document outlines the modernization approach for migrating the CBACT01C mainframe batch program to AWS. The program reads account records from an indexed file, processes the data, and writes the processed information into multiple output files with different formats. The modernization strategy focuses on creating a serverless, event-driven architecture that maintains the core business logic while leveraging AWS services for improved scalability, reliability, and cost efficiency.


### Implementation Roadmap and Dependencies

1. **Infrastructure Setup (Week 1)**
   - Create S3 buckets for input and output files
   - Configure IAM roles and policies
   - Set up CloudWatch logging and monitoring

2. **Core Processing Implementation (Week 2)**
   - Develop Lambda function for account data processing
   - Implement data transformation logic
   - Create output file generation modules

3. **Integration and Event Configuration (Week 3)**
   - Configure S3 event notifications
   - Set up error handling and retry mechanisms
   - Implement monitoring and alerting

4. **Testing and Validation (Week 4)**
   - Perform unit and integration testing
   - Validate data transformation accuracy
   - Test error handling and recovery

5. **Deployment and Cutover (Week 5)**
   - Deploy to production environment
   - Perform parallel runs with mainframe system
   - Monitor performance and make adjustments

### Data Flow Descriptions

1. **Input Processing**
   - Account data files are uploaded to the input S3 bucket
   - S3 event notification triggers the Lambda function
   - Lambda function reads and validates the input data

2. **Data Transformation**
   - Lambda function processes account records according to business rules
   - Performs data transformations and calculations
   - Handles special cases (e.g., default values for zero amounts)

3. **Output Generation**
   - Creates three different output formats:
     - Fixed-length records (equivalent to OUT-FILE)
     - Array-structured records (equivalent to ARRY-FILE)
     - Variable-length records (equivalent to VBRC-FILE)
   - Writes output files to the designated S3 bucket

### Security Considerations

- **Data Protection**
  - S3 buckets configured with server-side encryption
  - Data in transit protected with TLS
  - Bucket policies to restrict access

- **Access Control**
  - IAM roles with least privilege permissions
  - Resource-based policies for S3 buckets
  - Secure Lambda execution environment

- **Monitoring and Auditing**
  - CloudTrail for API activity logging
  - CloudWatch for operational monitoring
  - S3 access logging enabled

### Cost Optimization Strategies

- **Serverless Architecture**
  - Pay-only-for-what-you-use Lambda execution
  - No idle infrastructure costs

- **Storage Optimization**
  - S3 lifecycle policies for output file management
  - S3 storage class selection based on access patterns

- **Operational Efficiency**
  - Automated error handling reduces manual intervention
  - Event-driven architecture eliminates polling costs

### Monitoring and Logging Approach

- **Lambda Function Monitoring**
  - CloudWatch metrics for invocation count, duration, and errors
  - Custom metrics for business-specific KPIs

- **Comprehensive Logging**
  - Structured logging with consistent format
  - Log levels for different severity of events
  - Log retention policies aligned with business requirements

- **Alerting**
  - CloudWatch alarms for error thresholds
  - SNS notifications for critical failures
  - Dashboard for operational visibility

### Error Handling Strategies

- **Input Validation**
  - Validate file format and content before processing
  - Reject and notify on invalid input

- **Processing Errors**
  - Graceful handling of business rule exceptions
  - Detailed error messages with context

- **System Failures**
  - Automatic retries for transient failures
  - Dead-letter queue for persistent failures
  - Comprehensive error reporting

### Deployment Instructions

1. **Prerequisites**
   - AWS CLI configured with appropriate permissions
   - AWS SAM CLI installed for serverless deployment
   - Go 1.21+ for Lambda development

2. **Deployment Steps**
   - Clone the repository
   - Run `sam build` to build the application
   - Run `sam deploy --guided` for interactive deployment
   - Follow prompts to configure deployment parameters

3. **Verification**
   - Upload a test file to the input S3 bucket
   - Verify Lambda execution in CloudWatch Logs
   - Check output files in the output S3 bucket
```

## Architecture Components

### Go Lambda Functions
- **High Performance**: Go's compiled nature provides excellent cold start performance
- **Concurrency**: Built-in goroutines for concurrent processing
- **Memory Efficiency**: Low memory footprint ideal for Lambda cost optimization
- **Type Safety**: Strong static typing with comprehensive error handling
- **AWS SDK v2**: Latest AWS SDK for Go with improved performance

### Key Components:
- **Lambda Functions**: Lightning-fast processing with Go's performance advantages
- **Step Functions**: Orchestrate complex workflows with robust error handling
- **DynamoDB**: High-throughput data storage with Go's efficient JSON marshaling
- **S3**: Secure data storage with concurrent upload/download capabilities
- **IAM Roles**: Fine-grained security controls following AWS best practices

## Go-Specific Features
- **Modules**: Go modules for dependency management
- **Structured Logging**: Comprehensive logging with context
- **Error Handling**: Idiomatic Go error handling patterns
- **Testing**: Built-in testing framework with benchmarks
- **Cross-Compilation**: Build for Lambda's Linux environment from any OS
- **Minimal Dependencies**: Lean runtime with fast startup times

## Build and Deployment
```bash
# Build for Lambda (Linux)
GOOS=linux GOARCH=amd64 go build -o main main.go
zip function.zip main

# Deploy with SAM
sam build
sam deploy --guided
```

## Development
```bash
# Initialize Go module
go mod init mainframe-modernization

# Install dependencies
go mod tidy

# Run tests
go test ./...

# Run benchmarks
go test -bench=. ./...

# Format code
go fmt ./...

# Lint code
golangci-lint run
```

## Performance Optimizations
- **Connection Pooling**: Reuse AWS service clients across invocations
- **Memory Management**: Efficient memory usage with Go's garbage collector
- **Concurrent Processing**: Leverage goroutines for parallel operations
- **Binary Size**: Optimized binary size for faster Lambda deployments

## Security Considerations
- All data encrypted at rest and in transit
- IAM roles follow principle of least privilege
- Go's memory safety prevents common security vulnerabilities
- Secrets managed through AWS Secrets Manager
- Input validation with Go's strong typing system
```

## REASONING
### analysis.md
```markdown
# Analysis and Reasoning - Go Implementation

## Go-Specific Architecture Decisions

### Lambda Functions with Go 1.21+
**Selection Reasoning**: Go was chosen for Lambda functions because:
1. **Performance**: Compiled binaries provide excellent cold start performance
2. **Concurrency**: Built-in goroutines enable efficient concurrent processing
3. **Memory Efficiency**: Low memory footprint reduces Lambda costs
4. **Reliability**: Strong static typing and comprehensive error handling
5. **AWS Integration**: Excellent AWS SDK v2 support with performance optimizations

### Concurrency and Performance
**Go-Specific Advantages**:
1. **Goroutines**: Lightweight threads for concurrent mainframe data processing
2. **Channels**: Safe communication between concurrent operations
3. **Context Package**: Proper cancellation and timeout handling
4. **Fast Startup**: Compiled binaries start faster than interpreted languages
5. **Memory Management**: Efficient garbage collection suitable for serverless

### Error Handling Strategy
**Go-Specific Approach**:
1. **Explicit Errors**: Go's explicit error handling prevents silent failures
2. **Error Wrapping**: Context-aware error messages with fmt.Errorf
3. **Panic Recovery**: Graceful handling of unexpected panics
4. **Structured Logging**: Comprehensive logging with structured data

## Integration Strategy
This Go implementation integrates with AWS services through:
- **AWS SDK v2**: Latest SDK with improved performance and features
- **Context Propagation**: Proper context handling for timeouts and cancellation
- **CloudWatch Integration**: Native logging and metrics
- **X-Ray Tracing**: Distributed tracing for performance analysis

## Performance Considerations
- **Binary Optimization**: Minimal binary size for faster deployments
- **Connection Reuse**: Persistent AWS service clients across invocations
- **Memory Pooling**: Efficient memory usage patterns
- **Concurrent Processing**: Parallel processing of mainframe data chunks
- **Caching**: In-memory caching for frequently accessed data

## Security Best Practices
- **Type Safety**: Go's strong typing prevents many runtime errors
- **Input Validation**: Comprehensive validation using Go's type system
- **Memory Safety**: Go's memory management prevents buffer overflows
- **Dependency Management**: Go modules for secure dependency management
- **Secrets Management**: AWS Secrets Manager integration with proper error handling

## Mainframe Modernization Patterns
- **Batch Processing**: Efficient processing of large mainframe datasets
- **Data Transformation**: High-performance data format conversions
- **Concurrent Operations**: Parallel processing of multiple mainframe jobs
- **Error Recovery**: Robust error handling and retry mechanisms
```

Focus on Go's performance advantages, concurrency patterns, and AWS integration best practices. Ensure all code follows Go idioms and provides production-ready error handling, logging, and security considerations for mainframe modernization scenarios.
