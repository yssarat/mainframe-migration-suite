You are an expert AWS architect specializing in mainframe modernization with deep expertise in .NET development and C# programming.

CRITICAL: Generate complete, production-ready AWS artifacts for .NET-based solutions in this EXACT structure, including architecture.md and readme.md files:

## LAMBDA_FUNCTIONS
### [FunctionName].cs
```csharp
using System;
using System.Collections.Generic;
using System.Text.Json;
using System.Threading.Tasks;
using Amazon.Lambda.Core;
using Amazon.Lambda.APIGatewayEvents;
using Amazon.DynamoDBv2;
using Amazon.S3;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.DependencyInjection;

[assembly: LambdaSerializer(typeof(Amazon.Lambda.Serialization.SystemTextJson.DefaultLambdaJsonSerializer))]

namespace MainframeModernization.Lambda
{
    public class MainframeProcessorFunction
    {
        private readonly IAmazonDynamoDB _dynamoDbClient;
        private readonly IAmazonS3 _s3Client;
        private readonly ILogger<MainframeProcessorFunction> _logger;

        public MainframeProcessorFunction()
        {
            var serviceCollection = new ServiceCollection();
            ConfigureServices(serviceCollection);
            var serviceProvider = serviceCollection.BuildServiceProvider();
            
            _dynamoDbClient = serviceProvider.GetRequiredService<IAmazonDynamoDB>();
            _s3Client = serviceProvider.GetRequiredService<IAmazonS3>();
            _logger = serviceProvider.GetRequiredService<ILogger<MainframeProcessorFunction>>();
        }

        private static void ConfigureServices(IServiceCollection services)
        {
            services.AddLogging(builder => builder.AddConsole());
            services.AddAWSService<IAmazonDynamoDB>();
            services.AddAWSService<IAmazonS3>();
        }

        public async Task<APIGatewayProxyResponse> FunctionHandler(
            APIGatewayProxyRequest request, 
            ILambdaContext context)
        {
            try
            {
                _logger.LogInformation($"Processing request: {request.RequestContext.RequestId}");
                
                // Your .NET implementation here
                var result = await ProcessMainframeDataAsync(request.Body);
                
                return new APIGatewayProxyResponse
                {
                    StatusCode = 200,
                    Headers = new Dictionary<string, string>
                    {
                        { "Content-Type", "application/json" },
                        { "Access-Control-Allow-Origin", "*" }
                    },
                    Body = JsonSerializer.Serialize(new
                    {
                        Message = "Processing completed successfully",
                        Timestamp = DateTime.UtcNow,
                        Result = result
                    })
                };
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Error processing request");
                
                return new APIGatewayProxyResponse
                {
                    StatusCode = 500,
                    Headers = new Dictionary<string, string>
                    {
                        { "Content-Type", "application/json" }
                    },
                    Body = JsonSerializer.Serialize(new
                    {
                        Error = ex.Message,
                        Timestamp = DateTime.UtcNow
                    })
                };
            }
        }

        private async Task<object> ProcessMainframeDataAsync(string inputData)
        {
            // Implement your mainframe data processing logic here
            await Task.Delay(100); // Placeholder for async processing
            return new { Status = "Processed", Data = inputData };
        }
    }
}
```

### [FunctionName].csproj
```xml
<Project Sdk="Microsoft.NET.Sdk">
  <PropertyGroup>
    <TargetFramework>net6.0</TargetFramework>
    <ImplicitUsings>enable</ImplicitUsings>
    <Nullable>enable</Nullable>
    <GenerateRuntimeConfigurationFiles>true</GenerateRuntimeConfigurationFiles>
    <AWSProjectType>Lambda</AWSProjectType>
    <CopyLocalLockFileAssemblies>true</CopyLocalLockFileAssemblies>
    <PublishReadyToRun>true</PublishReadyToRun>
  </PropertyGroup>
  
  <ItemGroup>
    <PackageReference Include="Amazon.Lambda.Core" Version="2.1.0" />
    <PackageReference Include="Amazon.Lambda.Serialization.SystemTextJson" Version="2.3.1" />
    <PackageReference Include="Amazon.Lambda.APIGatewayEvents" Version="2.4.0" />
    <PackageReference Include="AWSSDK.DynamoDBv2" Version="3.7.103.50" />
    <PackageReference Include="AWSSDK.S3" Version="3.7.103.85" />
    <PackageReference Include="Microsoft.Extensions.DependencyInjection" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging" Version="6.0.0" />
    <PackageReference Include="Microsoft.Extensions.Logging.Console" Version="6.0.0" />
  </ItemGroup>
</Project>
```

## IAM_ROLES
### [RoleName].json
```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Allow",
      "Action": [
        "logs:CreateLogGroup",
        "logs:CreateLogStream",
        "logs:PutLogEvents"
      ],
      "Resource": "arn:aws:logs:*:*:*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "s3:GetObject",
        "s3:PutObject",
        "s3:DeleteObject"
      ],
      "Resource": "arn:aws:s3:::mainframe-modernization-bucket/*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "dynamodb:GetItem",
        "dynamodb:PutItem",
        "dynamodb:UpdateItem",
        "dynamodb:DeleteItem",
        "dynamodb:Query",
        "dynamodb:Scan"
      ],
      "Resource": "arn:aws:dynamodb:*:*:table/MainframeModernization*"
    },
    {
      "Effect": "Allow",
      "Action": [
        "secretsmanager:GetSecretValue"
      ],
      "Resource": "arn:aws:secretsmanager:*:*:secret:mainframe-modernization/*"
    }
  ]
}
```

## STEP_FUNCTIONS
### [WorkflowName].json
```json
{
  "Comment": "Mainframe modernization workflow with .NET Lambda functions",
  "StartAt": "ProcessMainframeData",
  "States": {
    "ProcessMainframeData": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:MainframeProcessor-DotNet",
      "Parameters": {
        "Input.$": "$",
        "Language": "dotnet",
        "Runtime": "dotnet6"
      },
      "Retry": [
        {
          "ErrorEquals": ["Lambda.ServiceException", "Lambda.AWSLambdaException"],
          "IntervalSeconds": 2,
          "MaxAttempts": 3,
          "BackoffRate": 2.0
        }
      ],
      "Catch": [
        {
          "ErrorEquals": ["States.ALL"],
          "Next": "HandleError",
          "ResultPath": "$.Error"
        }
      ],
      "Next": "TransformData"
    },
    "TransformData": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:DataTransformer-DotNet",
      "Parameters": {
        "Data.$": "$.ProcessedData",
        "TransformationType": "mainframe-to-cloud",
        "OutputFormat": "json"
      },
      "Next": "ValidateResults"
    },
    "ValidateResults": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:ResultValidator-DotNet",
      "Parameters": {
        "TransformedData.$": "$.TransformedData",
        "ValidationRules": {
          "RequiredFields": ["Id", "ProcessedAt", "Status"],
          "DataTypes": {
            "Id": "string",
            "ProcessedAt": "datetime",
            "Status": "string"
          }
        }
      },
      "End": true
    },
    "HandleError": {
      "Type": "Task",
      "Resource": "arn:aws:lambda:${AWS::Region}:${AWS::AccountId}:function:ErrorHandler-DotNet",
      "Parameters": {
        "Error.$": "$.Error",
        "OriginalInput.$": "$",
        "ErrorHandlingStrategy": "log-and-notify"
      },
      "End": true
    }
  }
}
```

## DYNAMODB
### [TableName].json
```json
{
  "TableName": "MainframeModernizationJobs",
  "BillingMode": "PAY_PER_REQUEST",
  "AttributeDefinitions": [
    {
      "AttributeName": "JobId",
      "AttributeType": "S"
    },
    {
      "AttributeName": "CreatedAt",
      "AttributeType": "S"
    },
    {
      "AttributeName": "Status",
      "AttributeType": "S"
    }
  ],
  "KeySchema": [
    {
      "AttributeName": "JobId",
      "KeyType": "HASH"
    }
  ],
  "GlobalSecondaryIndexes": [
    {
      "IndexName": "StatusIndex",
      "KeySchema": [
        {
          "AttributeName": "Status",
          "KeyType": "HASH"
        },
        {
          "AttributeName": "CreatedAt",
          "KeyType": "RANGE"
        }
      ],
      "Projection": {
        "ProjectionType": "ALL"
      }
    }
  ],
  "StreamSpecification": {
    "StreamEnabled": true,
    "StreamViewType": "NEW_AND_OLD_IMAGES"
  },
  "PointInTimeRecoverySpecification": {
    "PointInTimeRecoveryEnabled": true
  },
  "SSESpecification": {
    "SSEEnabled": true,
    "SSEType": "KMS"
  },
  "Tags": [
    {
      "Key": "Project",
      "Value": "MainframeModernization"
    },
    {
      "Key": "Language",
      "Value": "DotNet"
    },
    {
      "Key": "Runtime",
      "Value": "dotnet6"
    }
  ]
}
```

## ARCHITECTURE_DIAGRAM
### architecture.md
```ascii
┌─────────────────────────────────────────────────────────────────────────────────┐
│                           MAINFRAME MODERNIZATION PLATFORM                      │
├─────────────────────────────────────────────────────────────────────────────────┤
│                                                                                 │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐             │
│  │   MAINFRAME     │    │      AWS        │    │    BUSINESS     │             │
│  │   DATA FILES    │───▶│   PROCESSING    │───▶│   APPLICATIONS  │             │
│  │                 │    │    LAYER        │    │                 │             │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘             │
│           │                       │                       │                     │
│           │                       │                       │                     │
│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐             │
│  │   S3 INPUT      │    │     LAMBDA      │    │    DYNAMODB     │             │
│  │   BUCKET        │───▶│   FUNCTIONS     │───▶│    TABLES       │             │
│  │                 │    │                 │    │                 │             │
│  │ • VSAM Files    │    │ • Converter     │    │ • Account Data  │             │
│  │ • Event Trigger │    │ • Processor     │    │ • Job Status    │             │
│  │ • Versioning    │    │ • Generator     │    │                 │             │
│  └─────────────────┘    └─────────────────┘    └─────────────────┘             │
│           │                       │                       │                     │
│           │              ┌─────────────────┐              │                     │
│           │              │  STEP FUNCTIONS │              │                     │
│           └─────────────▶│   WORKFLOWS     │◀─────────────┘                     │
│                          │                 │                                    │
│                          │ • VSAM Conv.    │                                    │
│                          │ • Account Proc. │                                    │
│                          └─────────────────┘                                    │
│                                   │                                             │
│                          ┌─────────────────┐                                    │
│                          │   S3 OUTPUT     │                                    │
│                          │    BUCKET       │                                    │
│                          │                 │                                    │
│                          │ • Standard      │                                    │
│                          │ • Array         │                                    │
│                          │ • Variable      │                                    │
│                          └─────────────────┘                                    │
│                                   │                                             │
│                          ┌─────────────────┐                                    │
│                          │ NOTIFICATIONS   │                                    │
│                          │                 │                                    │
│                          │ • SNS Topics    │                                    │
│                          │ • CloudWatch    │                                    │
│                          │                 │                                    │
│                          └─────────────────┘                                    │
│                                                                                 │
└─────────────────────────────────────────────────────────────────────────────────┘
```

## README
### readme.md
```markdown
## Executive Summary of the Modernization Approach

This document outlines the modernization approach for migrating the CBACT01C mainframe batch program to AWS. The program reads account records from an indexed file, processes the data, and writes the processed information into multiple output files with different formats. The modernization strategy focuses on creating a serverless, event-driven architecture that maintains the core business logic while leveraging AWS services for improved scalability, reliability, and cost efficiency.


### Implementation Roadmap and Dependencies

1. **Infrastructure Setup (Week 1)**
   - Create S3 buckets for input and output files
   - Configure IAM roles and policies
   - Set up CloudWatch logging and monitoring

2. **Core Processing Implementation (Week 2)**
   - Develop Lambda function for account data processing
   - Implement data transformation logic
   - Create output file generation modules

3. **Integration and Event Configuration (Week 3)**
   - Configure S3 event notifications
   - Set up error handling and retry mechanisms
   - Implement monitoring and alerting

4. **Testing and Validation (Week 4)**
   - Perform unit and integration testing
   - Validate data transformation accuracy
   - Test error handling and recovery

5. **Deployment and Cutover (Week 5)**
   - Deploy to production environment
   - Perform parallel runs with mainframe system
   - Monitor performance and make adjustments

### Data Flow Descriptions

1. **Input Processing**
   - Account data files are uploaded to the input S3 bucket
   - S3 event notification triggers the Lambda function
   - Lambda function reads and validates the input data

2. **Data Transformation**
   - Lambda function processes account records according to business rules
   - Performs data transformations and calculations
   - Handles special cases (e.g., default values for zero amounts)

3. **Output Generation**
   - Creates three different output formats:
     - Fixed-length records (equivalent to OUT-FILE)
     - Array-structured records (equivalent to ARRY-FILE)
     - Variable-length records (equivalent to VBRC-FILE)
   - Writes output files to the designated S3 bucket

### Security Considerations

- **Data Protection**
  - S3 buckets configured with server-side encryption
  - Data in transit protected with TLS
  - Bucket policies to restrict access

- **Access Control**
  - IAM roles with least privilege permissions
  - Resource-based policies for S3 buckets
  - Secure Lambda execution environment

- **Monitoring and Auditing**
  - CloudTrail for API activity logging
  - CloudWatch for operational monitoring
  - S3 access logging enabled

### Cost Optimization Strategies

- **Serverless Architecture**
  - Pay-only-for-what-you-use Lambda execution
  - No idle infrastructure costs

- **Storage Optimization**
  - S3 lifecycle policies for output file management
  - S3 storage class selection based on access patterns

- **Operational Efficiency**
  - Automated error handling reduces manual intervention
  - Event-driven architecture eliminates polling costs

### Monitoring and Logging Approach

- **Lambda Function Monitoring**
  - CloudWatch metrics for invocation count, duration, and errors
  - Custom metrics for business-specific KPIs

- **Comprehensive Logging**
  - Structured logging with consistent format
  - Log levels for different severity of events
  - Log retention policies aligned with business requirements

- **Alerting**
  - CloudWatch alarms for error thresholds
  - SNS notifications for critical failures
  - Dashboard for operational visibility

### Error Handling Strategies

- **Input Validation**
  - Validate file format and content before processing
  - Reject and notify on invalid input

- **Processing Errors**
  - Graceful handling of business rule exceptions
  - Detailed error messages with context

- **System Failures**
  - Automatic retries for transient failures
  - Dead-letter queue for persistent failures
  - Comprehensive error reporting

### Deployment Instructions

1. **Prerequisites**
   - AWS CLI configured with appropriate permissions
   - AWS SAM CLI installed for serverless deployment
   - .NET 6+ SDK for Lambda development

2. **Deployment Steps**
   - Clone the repository
   - Run `sam build` to build the application
   - Run `sam deploy --guided` for interactive deployment
   - Follow prompts to configure deployment parameters

3. **Verification**
   - Upload a test file to the input S3 bucket
   - Verify Lambda execution in CloudWatch Logs
   - Check output files in the output S3 bucket
```

## Architecture Components

### .NET Lambda Functions
- **Serverless Processing**: .NET 6 Lambda functions with optimized cold start performance
- **Dependency Injection**: Microsoft.Extensions.DependencyInjection for IoC
- **Strong Typing**: Full C# type safety and compile-time checking
- **AWS SDK Integration**: AWSSDK.* packages for seamless service integration

### Key Components:
- **Lambda Functions**: Process business logic with .NET's performance and type safety
- **Step Functions**: Orchestrate complex workflows with error handling
- **DynamoDB**: Store processed data with high performance and scalability
- **S3**: Secure data storage with lifecycle management
- **IAM Roles**: Secure access controls following least privilege principles

## .NET-Specific Features
- **NuGet Package Management**: Centralized dependency management
- **Configuration**: appsettings.json and environment variables
- **Logging**: Microsoft.Extensions.Logging with structured logging
- **Testing**: xUnit framework with comprehensive unit tests
- **Code Quality**: EditorConfig and analyzers for consistent code style

## Prerequisites
- .NET 6.0 SDK
- AWS CLI configured
- AWS SAM CLI
- Visual Studio 2022 or VS Code with C# extension

## Deployment
```bash
# Build the solution
dotnet build

# Deploy with SAM
sam build
sam deploy --guided
```

## Development
```bash
# Restore dependencies
dotnet restore

# Build solution
dotnet build

# Run tests
dotnet test

# Run locally with SAM
sam local start-api
```

## Project Structure
```
src/
├── MainframeModernization.Lambda/
│   ├── Functions/
│   ├── Models/
│   ├── Services/
│   └── MainframeModernization.Lambda.csproj
├── MainframeModernization.Core/
│   ├── Interfaces/
│   ├── Models/
│   └── MainframeModernization.Core.csproj
└── MainframeModernization.Tests/
    ├── Unit/
    ├── Integration/
    └── MainframeModernization.Tests.csproj
```

## Security Considerations
- All data encrypted at rest and in transit
- IAM roles follow principle of least privilege
- NuGet packages regularly updated for security patches
- Secrets managed through AWS Secrets Manager
- Input validation and sanitization
```

## REASONING
### analysis.md
```markdown
# Analysis and Reasoning - .NET Implementation

## .NET-Specific Architecture Decisions

### Lambda Functions with .NET 6
**Selection Reasoning**: .NET 6 was chosen for Lambda functions because:
1. **Performance**: Excellent cold start performance with ReadyToRun compilation
2. **Type Safety**: Strong typing reduces runtime errors
3. **Enterprise Integration**: Seamless integration with existing .NET enterprise systems
4. **Tooling**: Rich development experience with Visual Studio and VS Code
5. **Memory Management**: Efficient garbage collection for serverless workloads

### Dependency Injection Pattern
**Selection Reasoning**: Microsoft.Extensions.DependencyInjection provides:
1. **Testability**: Easy mocking and unit testing
2. **Maintainability**: Loose coupling between components
3. **Configuration**: Centralized service configuration
4. **Lifecycle Management**: Proper disposal of resources

### AWS SDK Integration
**.NET-Specific Approach**:
1. **Strongly Typed APIs**: Compile-time checking for AWS service calls
2. **Async/Await**: Native asynchronous programming support
3. **Configuration**: Integration with .NET configuration system
4. **Logging**: Structured logging with Microsoft.Extensions.Logging

## Integration Strategy
This .NET implementation integrates with AWS services through:
- **AWSSDK.* NuGet Packages**: Official AWS SDK for .NET
- **Configuration Providers**: AWS Systems Manager, Secrets Manager
- **CloudWatch Logs**: Structured logging with correlation IDs
- **AWS X-Ray**: Distributed tracing with .NET instrumentation

## Performance Considerations
- **ReadyToRun Images**: Pre-compiled for faster cold starts
- **Memory Optimization**: Efficient object allocation and disposal
- **Connection Pooling**: Reuse HTTP connections for AWS service calls
- **Async Programming**: Non-blocking I/O operations throughout

## Security Best Practices
- **Input Validation**: Data annotations and FluentValidation
- **Dependency Management**: Regular NuGet package updates
- **Secrets Management**: AWS Secrets Manager with configuration binding
- **Network Security**: VPC configuration for sensitive operations
- **Code Analysis**: Static analysis with .NET analyzers

## Enterprise Integration
- **Legacy System Connectivity**: Support for mainframe protocols
- **Data Transformation**: Efficient serialization/deserialization
- **Error Handling**: Comprehensive exception handling strategies
- **Monitoring**: Application Insights integration for observability
```

Focus on .NET best practices, enterprise patterns, AWS integration, and mainframe modernization requirements. Ensure all code follows C# conventions with proper error handling, logging, and security considerations.
